import java.util.Random;

import org.eclipse.swt.SWT;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Text;

import weka.classifiers.Evaluation;
import weka.classifiers.functions.MultilayerPerceptron;
import weka.classifiers.meta.FilteredClassifier;
import weka.core.Instances;
import weka.core.converters.ConverterUtils.DataSource;
import weka.filters.unsupervised.attribute.Remove;

/**
 * 
 */

/**
 * @author mawo
 *
 */
public class TestModel implements Runnable {
	   private Thread t;
	   private String threadName;
	   private String[] fil, opt;
	   private Shell shell;
	   
	   public TestModel(String name){
	       threadName = name;
	       System.out.println("Creating " +  threadName );
	   }
	   
	   public void run() {
	      System.out.println("Running " +  threadName );
	      try {
				//Expander ex = new Expander(db);
				//expand profil0
				//ex.expand("SELECT * FROM `profil8` ORDER BY `Unixtime`", "INSERT INTO profil8training (`Unixtime`,`Reltime`,`Spannung`,`Stromstärke`,`Wirkleistung`, `Klasse`)", 1384066710, 5550);
				//FeatureWriter fw = new FeatureWriter(db, false);
				/*fw.zeitreihe("SELECT * FROM `training` ORDER BY `Unixtime`", "INSERT INTO `trainingzeitnorm` (`Unixtime`, "
						+ "`Wirkleistung t-10`, `Wirkleistung t-9`, `Wirkleistung t-8`, `Wirkleistung t-7`, `Wirkleistung t-6`, "
						+ "`Wirkleistung t-5`, `Wirkleistung t-4`, `Wirkleistung t-3`, `Wirkleistung t-2`, `Wirkleistung t-1`, "
						+ "`Wirkleistung t+0`, `Wirkleistung t+1`, `Wirkleistung t+2`, `Wirkleistung t+3`, `Wirkleistung t+4`, "
						+ "`Wirkleistung t+5`, `Wirkleistung t+6`, `Wirkleistung t+7`, `Wirkleistung t+8`, `Wirkleistung t+9`, "
						+ "`Wirkleistung t+10`, `Klasse`)", 1382290611, 1384072259);
				*/
				//fw.experte("SELECT * FROM `training` ORDER BY `Unixtime`", "INSERT INTO `experte` (`Unixtime`, `Wirkleistung`, `FolgeDurchschnitt`, `MaxWirkleistung`, `MinPeakWirkleistung`,`Klasse`)", 1382290611, 1384072259);
				 
			
	    	
			Text results = new Text(shell, SWT.MULTI);
			
			shell.setLayout(new FillLayout());
			shell.setSize(400, 500);
			results.setText("computing...");
			results.setEditable(false);
			
		
			
				 DataSource source = new DataSource("C:\\Users\\mawo\\Documents\\GitHub\\Thesis\\workspace\\ApplianceStateSeperator\\src\\trainingszeit.arff");
				 Instances data = source.getDataSet();
				 if (data.classIndex() == -1)
					   data.setClassIndex(data.numAttributes() - 1);
				 
				 //System.out.println("Successfully loaded Data\n");
				 
				 //String[] optionsrm = weka.core.Utils.splitOptions("-R 1");
				 /*
				 NumericToNominal ntn = new NumericToNominal();
				 ntn.setAttributeIndices("last");
				 ntn.setInputFormat(data);                          
				 Instances newData = Filter.useFilter(data, ntn);
				 */
				 Remove rm = new Remove(); 
				 rm.setOptions(fil);                        
				 //remove.setOptions(optionsrm);                           
				 //remove.setInputFormat(data);  
				 //Instances newData = Filter.useFilter(data, rm);  
				 
				 MultilayerPerceptron mlp = new MultilayerPerceptron();
				 mlp.setOptions(opt);
				 
				 FilteredClassifier fc = new FilteredClassifier();
				 fc.setFilter(rm);
				 fc.setClassifier(mlp);
				 
			String[] options = mlp.getOptions();
			String title = "MultiLayerPerceptron ";
			for (String option : options) title += option + " ";
			
			
			shell.setText(title);
			//shell.open();		 
				 
				 Evaluation eval = new Evaluation(data);
				 eval.crossValidateModel(fc, data, 10, new Random(1));
				 
				 String res = eval.toSummaryString(false) + "\n" + eval.toClassDetailsString() + "\n" + eval.toMatrixString();
			//results.setText(res);
	     } catch (Exception e) {
	         System.out.println(e);
	     }
	     System.out.println("Thread " +  threadName + " exiting.");
	   }
	   
	   public void start (Shell s, String[] o, String[] f)
	   {
		  shell = new Shell(s);
		  opt = o;
		  fil = f;
	      System.out.println("Starting " +  threadName );
	      if (t == null)
	      {
	         t = new Thread (this, threadName);
	         t.start ();
	      }
	   }

}
